pipeline {
    // Usar agente padr√£o do Jenkins (Azure App Service n√£o exp√µe Docker socket)
    // O container Jenkins j√° possui Docker, Docker Compose, Azure CLI e ferramentas necess√°rias
    agent any

    environment {
        APP_NAME = 'sdc'
        DOCKER_COMPOSE = 'docker-compose -f docker-compose.prod.yml'

        // Vari√°veis para Docker Buildkit (melhora performance)
        DOCKER_BUILDKIT = '1'
        COMPOSE_DOCKER_CLI_BUILD = '1'

        // Diret√≥rios de cache (resolve problema de workspace crescer infinito)
        COMPOSER_CACHE_DIR = "${WORKSPACE}/.composer-cache"
        NPM_CACHE_DIR = "${WORKSPACE}/.npm-cache"

        // Azure Container Registry
        ACR_NAME = 'apidover'
        ACR_LOGIN_SERVER = 'apidover.azurecr.io'
        ACR_IMAGE = 'apidover.azurecr.io/sdc-dev-app'
        ACR_TAG = "${env.BUILD_NUMBER}-${env.GIT_COMMIT.take(7)}"
    }

    options {
        // Timeout global para evitar builds travados
        timeout(time: 30, unit: 'MINUTES')

        // Manter apenas √∫ltimos 10 builds
        buildDiscarder(logRotator(numToKeepStr: '10', artifactNumToKeepStr: '5'))

        // Timestamps nos logs
        timestamps()

        // Colorir output
        ansiColor('xterm')
    }

    // Trigger autom√°tico via webhook do GitHub
    triggers {
        githubPush()
    }

    stages {
        stage('Checkout') {
            steps {
                echo 'üì¶ Checking out code...'
                // Resolve problema SSH: usar credenciais configuradas
                checkout scm

                // Exibir informa√ß√µes do commit
                script {
                    env.GIT_COMMIT_MSG = sh(
                        script: 'git log -1 --pretty=%B',
                        returnStdout: true
                    ).trim()
                    env.GIT_AUTHOR = sh(
                        script: 'git log -1 --pretty=%an',
                        returnStdout: true
                    ).trim()
                }
                echo "Commit: ${env.GIT_COMMIT_MSG}"
                echo "Author: ${env.GIT_AUTHOR}"
            }
        }

        stage('Pre-flight Checks') {
            steps {
                echo 'üîç Running pre-flight checks...'

                script {
                    // Verificar se Docker est√° dispon√≠vel
                    sh 'docker --version'
                    sh 'docker-compose --version'

                    // Verificar espa√ßo em disco (m√≠nimo 5GB)
                    def availableSpace = sh(
                        script: "df -BG ${WORKSPACE} | tail -1 | awk '{print \$4}' | sed 's/G//'",
                        returnStdout: true
                    ).trim().toInteger()

                    if (availableSpace < 5) {
                        error("Espa√ßo em disco insuficiente: ${availableSpace}GB. M√≠nimo: 5GB")
                    }
                    echo "‚úÖ Espa√ßo dispon√≠vel: ${availableSpace}GB"

                    // Verificar se .env existe
                    if (!fileExists('.env')) {
                        echo '‚ö†Ô∏è  .env n√£o encontrado, copiando de .env.example'
                        sh 'cp .env.example .env'
                    }
                }
            }
        }

        stage('Build Docker Images') {
            steps {
                echo 'üèóÔ∏è  Building Docker images for production...'

                script {
                    // Resolver problema de mem√≥ria: limpar builds antigos
                    sh 'docker system prune -f --filter "until=24h"'

                    // Verificar se estamos no diret√≥rio correto
                    sh 'pwd && ls -la'

                    // Build da imagem de produ√ß√£o usando Dockerfile.prod
                    // O contexto √© o diret√≥rio SDC (onde est√° o Jenkinsfile)
                    sh """
                        docker build \
                            -f docker/Dockerfile.prod \
                            -t sdc-dev-app:latest \
                            -t ${ACR_IMAGE}:${ACR_TAG} \
                            -t ${ACR_IMAGE}:latest \
                            .
                    """

                    echo "‚úÖ Imagem buildada: sdc-dev-app:latest"
                    echo "‚úÖ Imagem taggeada: ${ACR_IMAGE}:${ACR_TAG}"
                    echo "‚úÖ Imagem taggeada: ${ACR_IMAGE}:latest"
                }
            }
        }

        stage('Tag and Push to ACR') {
            steps {
                echo 'üì¶ Tagging and pushing images to Azure Container Registry...'

                script {
                    // Verificar se Azure CLI est√° instalado
                    def azCliInstalled = sh(
                        script: 'which az || command -v az',
                        returnStatus: true
                    ) == 0

                    if (!azCliInstalled) {
                        echo '‚ö†Ô∏è  Azure CLI n√£o encontrado. Instalando...'
                        sh '''
                            curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash || \
                            curl -sL https://aka.ms/InstallAzureCLI | sudo bash || \
                            echo "‚ö†Ô∏è  Falha ao instalar Azure CLI. Continuando sem push para ACR..."
                        '''
                    }

                    // Tentar login no Azure usando Service Principal ou credenciais do ACR
                    def loginSuccess = false

                    // M√©todo 1: Service Principal (recomendado)
                    try {
                        withCredentials([usernamePassword(
                            credentialsId: 'azure-service-principal',
                            usernameVariable: 'AZURE_CLIENT_ID',
                            passwordVariable: 'AZURE_CLIENT_SECRET'
                        )]) {
                            def tenantId = env.AZURE_TENANT_ID ?: ''
                            if (tenantId) {
                                sh """
                                    az login --service-principal \
                                        --username \$AZURE_CLIENT_ID \
                                        --password \$AZURE_CLIENT_SECRET \
                                        --tenant ${tenantId}
                                """
                                loginSuccess = true
                                echo "‚úÖ Login no Azure via Service Principal realizado"
                            }
                        }
                    } catch (Exception e) {
                        echo "‚ö†Ô∏è  Service Principal n√£o configurado: ${e.message}"
                    }

                    // M√©todo 2: Login direto no ACR (fallback)
                    if (!loginSuccess) {
                        try {
                            withCredentials([usernamePassword(
                                credentialsId: 'azure-acr-credentials',
                                usernameVariable: 'ACR_USERNAME',
                                passwordVariable: 'ACR_PASSWORD'
                            )]) {
                                sh """
                                    echo \$ACR_PASSWORD | docker login ${ACR_LOGIN_SERVER} \
                                        --username \$ACR_USERNAME \
                                        --password-stdin
                                """
                                loginSuccess = true
                                echo "‚úÖ Login no ACR realizado diretamente"
                            }
                        } catch (Exception e) {
                            echo "‚ö†Ô∏è  Credenciais do ACR n√£o configuradas: ${e.message}"
                        }
                    }

                    // M√©todo 3: Login interativo (√∫ltimo recurso)
                    if (!loginSuccess && azCliInstalled) {
                        echo "‚ö†Ô∏è  Tentando login interativo no Azure..."
                        sh "az acr login --name ${ACR_NAME}" || {
                            echo "‚ùå Falha ao fazer login no ACR. Pulando push..."
                            return
                        }
                        loginSuccess = true
                    }

                    if (loginSuccess) {
                        // As imagens j√° foram taggeadas no stage de build
                        // Apenas fazer push para ACR
                        echo "üì§ Fazendo push das imagens para ACR..."

                        sh """
                            docker push ${ACR_IMAGE}:${ACR_TAG} || {
                                echo "‚ö†Ô∏è  Erro ao fazer push da tag ${ACR_TAG}, tentando novamente..."
                                docker push ${ACR_IMAGE}:${ACR_TAG}
                            }
                        """

                        sh """
                            docker push ${ACR_IMAGE}:latest || {
                                echo "‚ö†Ô∏è  Erro ao fazer push da tag latest, tentando novamente..."
                                docker push ${ACR_IMAGE}:latest
                            }
                        """

                        echo "‚úÖ Imagens enviadas para ACR:"
                        echo "   - ${ACR_IMAGE}:${ACR_TAG}"
                        echo "   - ${ACR_IMAGE}:latest"
                    } else {
                        echo "‚ùå N√£o foi poss√≠vel fazer login no ACR. Push cancelado."
                        echo "üí° Configure as credenciais do Azure no Jenkins:"
                        echo "   1. azure-service-principal (recomendado)"
                        echo "   2. azure-acr-credentials (fallback)"
                        error("Falha ao fazer login no ACR. Configure as credenciais.")
                    }
                }
            }
        }

        stage('Verify Build') {
            steps {
                echo '‚úÖ Verificando build da imagem...'
                script {
                    // Verificar se a imagem foi criada corretamente
                    sh """
                        docker images | grep sdc-dev-app || exit 1
                        docker inspect sdc-dev-app:latest | grep -q '\"Architecture\"' || exit 1
                    """
                    echo "‚úÖ Imagem verificada com sucesso!"
                    echo "‚ÑπÔ∏è  Nota: Depend√™ncias PHP/Node e assets j√° foram instalados/compilados durante o build"
                }
            }
        }

        stage('Code Quality & Tests') {
            when {
                // Executar apenas em branches de desenvolvimento
                not {
                    anyOf {
                        branch 'main'
                        branch 'master'
                    }
                }
            }
            steps {
                echo 'üîç Running code quality checks and tests...'
                echo '‚ÑπÔ∏è  Para produ√ß√£o, testes s√£o executados em ambiente de staging'
                // Em produ√ß√£o, confiamos no build da imagem que j√° passou por valida√ß√µes
            }
        }


        stage('Deploy to Azure App Service') {
            when {
                anyOf {
                    branch 'main'
                    branch 'master'
                }
            }
            steps {
                echo 'üöÄ Deploying to Azure App Service AUTOMATICALLY...'

                script {
                    // Verificar se Azure CLI est√° dispon√≠vel
                    sh 'az --version || (echo "Azure CLI n√£o encontrado" && exit 1)'

                    // Vari√°veis do App Service (configurar no Jenkins)
                    def APP_SERVICE_NAME = env.AZURE_APP_SERVICE_NAME ?: 'newsdc2027'
                    def RESOURCE_GROUP = env.AZURE_RESOURCE_GROUP ?: 'DEFESA_CIVIL'
                    def ACR_NAME = env.ACR_NAME ?: 'apidover'

                    // Fazer login no Azure usando Service Principal
                    withCredentials([usernamePassword(
                        credentialsId: 'azure-service-principal',
                        usernameVariable: 'AZURE_CLIENT_ID',
                        passwordVariable: 'AZURE_CLIENT_SECRET'
                    )]) {
                        def tenantId = env.AZURE_TENANT_ID ?: ''
                        if (!tenantId) {
                            error("AZURE_TENANT_ID n√£o configurado. Configure no Jenkins: Manage Jenkins ‚Üí Configure System ‚Üí Global properties")
                        }

                        sh """
                            az login --service-principal \
                                --username \$AZURE_CLIENT_ID \
                                --password \$AZURE_CLIENT_SECRET \
                                --tenant ${tenantId}
                        """

                        // Fazer login no ACR
                        sh "az acr login --name ${ACR_NAME}"

                        // Obter credenciais do ACR para configurar no App Service
                        def acrUsername = sh(
                            script: "az acr credential show --name ${ACR_NAME} --query username -o tsv",
                            returnStdout: true
                        ).trim()

                        def acrPassword = sh(
                            script: "az acr credential show --name ${ACR_NAME} --query 'passwords[0].value' -o tsv",
                            returnStdout: true
                        ).trim()

                        // Atualizar App Service com nova imagem
                        echo "Atualizando App Service: ${APP_SERVICE_NAME}"
                        echo "Imagem: ${ACR_IMAGE}:${ACR_TAG}"
                        sh """
                            az webapp config container set \\
                                --name ${APP_SERVICE_NAME} \\
                                --resource-group ${RESOURCE_GROUP} \\
                                --docker-custom-image-name ${ACR_IMAGE}:${ACR_TAG} \\
                                --docker-registry-server-url https://${ACR_LOGIN_SERVER} \\
                                --docker-registry-server-user ${acrUsername} \\
                                --docker-registry-server-password ${acrPassword}
                        """
                    }

                    // Reiniciar App Service para aplicar nova imagem
                    echo "Reiniciando App Service..."
                    sh """
                        az webapp restart \\
                            --name ${APP_SERVICE_NAME} \\
                            --resource-group ${RESOURCE_GROUP}
                    """

                    // Health check no App Service
                    def APP_URL = "https://${APP_SERVICE_NAME}.azurewebsites.net"
                    echo "Verificando sa√∫de da aplica√ß√£o em ${APP_URL}..."

                    timeout(time: 5, unit: 'MINUTES') {
                        sh """
                            for i in {1..30}; do
                                if curl -f ${APP_URL}/health 2>/dev/null; then
                                    echo "‚úÖ App Service est√° respondendo!"
                                    exit 0
                                fi
                                echo "Tentativa \$i/30: Aguardando aplica√ß√£o..."
                                sleep 10
                            done
                            echo "‚ö†Ô∏è  App Service n√£o respondeu no tempo esperado"
                            exit 1
                        """
                    }

                    echo "‚úÖ Deploy para Azure App Service conclu√≠do!"
                    echo "üåê URL: ${APP_URL}"
                }
            }
        }

    }

    post {
        always {
            echo 'üßπ Cleaning up...'

            script {
                // Resolver problema: N√ÉO fazer down no ambiente de produ√ß√£o!
                // Apenas limpar containers tempor√°rios
                sh 'docker ps -a --filter "status=exited" -q | xargs -r docker rm || true'

                // Limpar imagens n√£o utilizadas
                sh 'docker image prune -f --filter "dangling=true" || true'

                // Limpar workspace cache (manter apenas √∫ltimos 3 builds)
                sh """
                    find ${WORKSPACE}/.composer-cache -type f -mtime +7 -delete || true
                    find ${WORKSPACE}/.npm-cache -type f -mtime +7 -delete || true
                """
            }
        }

        success {
            echo '‚úÖ Pipeline completed successfully!'

            // Notifica√ß√£o de sucesso (configurar no Jenkins)
            // slackSend color: 'good', message: "Build #${env.BUILD_NUMBER} succeeded"
        }

        failure {
            echo '‚ùå Pipeline failed!'

            script {
                // Coletar informa√ß√µes do build para debugging
                sh """
                    echo '=== Build Information ===' > build-info.txt
                    echo "Build Number: ${env.BUILD_NUMBER}" >> build-info.txt
                    echo "Git Commit: ${env.GIT_COMMIT}" >> build-info.txt
                    echo "Git Branch: ${env.GIT_BRANCH}" >> build-info.txt
                    echo "ACR Image: ${ACR_IMAGE}:${ACR_TAG}" >> build-info.txt
                    docker images | grep sdc-dev-app >> build-info.txt || true
                """
                archiveArtifacts artifacts: 'build-info.txt', allowEmptyArchive: true
            }

            // Notifica√ß√£o de falha
            // slackSend color: 'danger', message: "Build #${env.BUILD_NUMBER} failed"
        }

        unstable {
            echo '‚ö†Ô∏è  Pipeline completed with warnings'
        }
    }
}
